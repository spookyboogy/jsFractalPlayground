
 ####################
### ╭────────────╮ ### 
### │############│ ###
### │## spooky ##│ ###
### │############│ ###
### ╰────────────╯ ###
 ####################

alias bashrc="vim -c 'normal G' ~/.bashrc"
alias vimrc="vim ~/.vimrc"
alias srcbash='source ~/.bashrc'
alias hellworld='cd ~/js/hellwoorld'

alias ll="ls -alF"
alias lx='ls -lXB'
alias lt='ls -ltr'
alias la='ls -laht'

## macro for committing and pushing to main
## commitmain "custom commit message" // default is 'Update'
commitmain() {
    git -C "$(git rev-parse --show-toplevel)" add -A \
    && git -C "$(git rev-parse --show-toplevel)" commit -m "${1:-Update}" \
    && git -C "$(git rev-parse --show-toplevel)" push origin main
}

## I'm having gpt help write my ~/.bashrc, so which involves copy+pasting or `cat`ing a lot
## This function makes it easy to `cat`  only the user-defined section of this machine's ~/.bashrc
## , which, in the case of my ~/.bashrc, is denoted by the first line containing "spooky". 
show_spooky_bashrc() {
    local start_line=$(grep -n 'spooky' ~/.bashrc | head -1 | cut -d: -f1)
    local end_line=$(wc -l < ~/.bashrc)
    local display_lines=$((end_line - start_line + 1))

    if ((start_line > 4)); then
        start_line=$((start_line - 4))
        display_lines=$((display_lines + 4))
    else
        start_line=1
    fi

    tail -n +"$start_line" ~/.bashrc | head -n "$display_lines"
}
alias spookyrc='show_spooky_bashrc'

## Hardcoded example command for `cat`ing a bunch of files to txt with clear divisions between files.
## Meant to make copy+pasting your project into gpt faster, to help speed up gpt-copiloted development
alias hardctx="(spookyrc && 
                echo -e '\n==== ex1.html ====\n' &&
	        echo -e '\n==== ex1.html ====\n' &&
	        cat ~/js/hellwoorld/ex1.html && 
	        echo -e '\n==== ex1.js ====\n' && 
	        cat ~/js/hellwoorld/ex1.js) > jsgpt.txt"

##
gpt_context() {
  local merged_file="gpt_context.txt"

  if [ $# -eq 0 ]; then
    set -- ~/js/hellwoorld/ex1.html ~/js/hellwoorld/ex1.js
  fi

  for file in "$@"; do
    echo -e "\n==== $file ====\n"
    cat "$file"
  done > "$merged_file"

  echo "GPT context files merged and saved to $merged_file"
}

# Aliases for gpt_context 
alias gptctx='gpt_context'
alias ctx='cd ~/js/hellwoorld && gpt_context ex1.html ex1.js' 

#########################################################
### Functions for doing js/html stuff on a chromebook ###
#########################################################
## Optional deps
## 	- ccze - colorize terminal output 
## 	- nc - netcat - network utility
## 	- neofetch - nice sysinfo display sticker
##	- lsof ( used in ccport() not optional atm actually)
##
## ToDo
## 	- solve currentBugs
##
## currentBugs
## 	- ccport doesn't work on no arguments
## 	- not all functions which accept arguments or flags do accept arbitrary argument order
## 	- not all functions have help strings / docs , not all accept -h --help flags
## 	- ccze isn't colorizing http access logs
#########################################################

alias openlocal='open_localhost'
alias openjs='hellworld && run_neofetch && open_localhost && open_browser'

## Runs neofetch if installed, serves as a nice terminal sticker before starting http server
run_neofetch () {
  # Check if neofetch is installed
  if command -v neofetch >/dev/null 2>&1; then
    neofetch
  fi
}

## open_localhost for opening a localhost server with colorized output
open_localhost () {
  local port="${1:-8000}"  # Use port argument if provided, otherwise default to 8080
  
  # Check if nc command exists
  if command -v nc >/dev/null 2>&1; then
    # Check if localhost:port is already running (using nc)
    if ! nc -z localhost "$port" >/dev/null 2>&1; then
      echo "Starting localhost server on port $port..."
	      python3 -m http.server "$port" | ccze -A 
      echo "Server started."
    else
      echo "Localhost server already running on port $port."
    fi
  else
    # Check if localhost:port is already running (using timeout)
    if ! timeout 1 bash -c "echo >/dev/tcp/localhost/$port" >/dev/null 2>&1; then
      echo "Starting localhost server on port $port..."
      python3 -m http.server "$port" | ccze -A 
      echo "Server started."
    else
      echo "Localhost server already running on port $port."
    fi
  fi
}

## open_browser calls garcon-url-handler, used for opening a native chromeOS browser
## window from within a linux container (penguin) typically found in /usr/bin/
## more info :
## 	- https://chromium.googlesource.com/chromiumos/containers/cros-container-guest-tools/+/master/cros-garcon/garcon-url-handler
## Accepts a valid url as an argument, opens most recently edited html file in $PWD by default 
open_browser() {
  local port=8000
  local html_file=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      -p)
        shift
        port=$1
        ;;
      -h|--help)
        echo "Usage: open_browser [HTML_FILE] [-p PORT]"
        echo "Open an HTML file in a new Chrome window."
        echo "If HTML_FILE is not provided, the most recently modified HTML" 
	echo "file in the current directory will be opened."
        echo "Options:"
        echo "  -p PORT   Specify the port number (default: 8000)"
        echo "  -h, --help   Show help"
        return
        ;;
      *)
        html_file=$1
        ;;
    esac
    shift
  done

  if [ -z "$html_file" ]; then
    # Find the most recently modified HTML file in the current directory
    html_file=$(ls -t *.html 2>/dev/null | head -n 1)

    if [ -z "$html_file" ]; then
      echo "No HTML files found in the current directory."
      return 1
    fi
  fi

  echo "Opening $html_file in a new Chrome window at port $port..."
  garcon-url-handler "http://localhost:${port}/${html_file}" -new-window
}

## ccport / check_and_close_port 
## 	- write in a check for `lsof` and use an alternate method if found to be not available.
## 	- maybe have behavior on no args check a list of common localhost ports, give status of each,
## 	  	and close each, with optional flag for specifying ports not to kill.
check_and_close_port() {
    local close_port=true
    local port=${1:-8000}  # Use port 8000 as the default if no argument is provided

    # Help dialogue
    local help_message="Usage: ccport [-k] [<port>]
    Check if a port is open and optionally close it.

    `check_and_close_port` with no args passed 
    checks port 8000 and attempts to close it.

    alias `ccport`

    Options:
      -k            Do not close the port.
      -h, --help    Display this help dialogue."

    # Parse command-line options
    while getopts ":kh" opt; do
        case $opt in
            k)
                close_port=false
                ;;
            h|--help)
                echo "$help_message"
                return 0
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                echo "$help_message"
                return 1
                ;;
        esac
    done

    # Shift to the next option index
    shift $((OPTIND - 1))
    OPTIND=1  # Reset getopts index

    # Process the remaining arguments
    if [ $# -eq 1 ]; then
        port=$1
    elif [ $# -gt 1 ]; then
        echo "Invalid arguments" >&2
        echo "$help_message"
        return 1
    fi

    # Step 2: Check if process is running on the specified port
    nc -zv localhost "$port" > /dev/null 2>&1
    local is_open=$?

    if [ "$is_open" -eq 0 ]; then
        echo "Port $port is open."
    else
        echo "Port $port is not open."
        close_port=false
    fi

    # Step 3: Close the process if close_port is true and the port is open
    if [ "$close_port" = true ] && [ "$is_open" -eq 0 ]; then
        echo "Closing $port."
        sudo kill "$(sudo lsof -t -i:"$port")"
    fi
}
alias ccport='check_and_close_port'


==== ex1.html ====


==== ex1.html ====

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fractal and Pyramid</title>

  <style>
    body {
      background-color: #1f1f1f;
      color: #ffffff;
      font-family: Arial, sans-serif;
    }

    #fractalCanvas {
      /* background-color: #000000; */
			width: 100%;
			height: 100%;
		}

    #titleContainer {
      text-align: center;
      padding: 20px;
    }
  </style>
</head>

<body>
  <div id="titleContainer">
    <h1>triangle</h1>
		
		<h2 id="subhead"></h2>

			<script>
				var s1 = " \u25B2 ";
				var s2 = " \u25BC ";
				var fullSubhead = s1 + "<br>" + s1.repeat(2) + "<br>" + s1.repeat(3);
				var subheadElement = document.getElementById("subhead");
				subheadElement.innerHTML = fullSubhead;
			</script>

  </div>

	<div id="canvasContainer">
		<canvas id="fractalCanvas" width="600" height="600"></canvas>
	</div>

  <div id="pyramidContainer"></div>

  <script type="module" src="ex1.js"></script>
</body>

</html>

==== ex1.js ====

// 
// llolearning javascript with fractals

import palettes from './colorPalettes.js';

const canvas = document.getElementById('fractalCanvas');
const ctx = canvas.getContext('2d');

const pyramidContainer = document.getElementById('pyramidContainer');

let startX = 300; // X-coordinate of the triangle's starting point
let startY = 300; // Y-coordinate of the triangle's starting point
const size = 200; // Length of the triangle's sides
const iterations = 8; // Number of iterations to display

// for each palette:
//   draw fractal of increasing iteration level and proportionally decreasing 
//     line width. each new iteration level being slightly shifted on the canvas (eg down,left)
//   refresh canvas

// setting combos, interesting math there (related to colorIndex % palette.length) 
// palette5 , 8 iterations, 0.6 width
// palette4, 7, .75
// palette2, 8, .75
// palette5, 11, .125

// const { palette1 } = palettes; // Access palette4 directly
const strokeColors = palettes.palette2; // Assigning palette to strokeColors

let colorIndex = 0;

async function drawFractal(x, y, size, iterations, colorIndex) {
    if (iterations === 0) {
    // Base case: Stop recursion when iterations reach 0
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x + size / 2, y + (Math.sqrt(3) * size) / 2);
        ctx.closePath();
        ctx.strokeStyle = strokeColors[colorIndex % strokeColors.length];
        ctx.lineWidth = .75; // 
        ctx.stroke();
  } else {
    // Recursive case: Generate three smaller triangles
		await drawFractalStep(x, y, size, iterations, colorIndex);
	}
}

// async function drawSecondFractal(x, y, size, iterations, colorIndex) {
//   // Calculate the shifted coordinates
//   const shiftedX = x + 20;
//   const shiftedY = y + 20;
// 
//   // Draw the second fractal with the shifted coordinates
//   await drawFractal(shiftedX, shiftedY, size, iterations, colorIndex);
// }


async function drawFractalStep(x, y, size, iterations, colorIndex) {

    await new Promise((resolve) => setTimeout(resolve, 0.0001)); // ms
				
        await drawFractal(x, y, size / 2, 
                        iterations - 1, 
                        colorIndex + 1); //
        await drawFractal(x + size / 2, y, size / 2, 
                        iterations - 1, 
                        colorIndex + 2); // 
        await drawFractal(x + size / 4, y + (Math.sqrt(3) * size) / 4, size / 2, 
                        iterations - 1, 
                        colorIndex + 3); // 
}

async function updateCanvasSize() {
    
    //   ctx.clearRect(0, 0, canvas.width, canvas.height);

    const containerWidth = canvas.parentNode.clientWidth;
    const containerHeight = canvas.parentNode.clientHeight;
    const canvasSize = Math.min(containerWidth, containerHeight);
  
    canvas.width = canvasSize;
    canvas.height = canvasSize;

    const triangleHeight = (Math.sqrt(3) * canvasSize) / 2;

    const startX = canvas.width / 2 - canvasSize / 2;
    const startY = canvas.height / 2 - triangleHeight / 2;

    await drawFractal(startX, startY, canvasSize, iterations, colorIndex);

    // // Draw the second fractal
    // const secondStartX = startX + 20;
    // const secondStartY = startY + 20;
    // await drawSecondFractal(secondStartX, secondStartY, size, iterations, 0);
}

function printPyramid(baseSize) {
  // Loop through the rows of the pyramid
  for (let row = 1; row <= baseSize; row++) {
    // Print spaces to create an indentation for each row
    let spaces = ' '.repeat(baseSize - row);
    // Print the triangles in each row
    let triangles = '*'.repeat(row * 2 - 1);
    // Combine the spaces and triangles to form the row
    let rowOutput = spaces + triangles;
    // Print the row to the console
    console.log(rowOutput); 
  }
}


/**
 * iterLoop : Draw the fractal triangle with 'palette' color palette
 *            and 
 *
 * @param {integer} iterations - The iterative depth of the fractal.
 * @param {color palette container} palette - The second argument.
 * 
 */

function iterLoop(iterations = 7, palette = colorStrokes, ) {
    
    


}




var msg = "hellooo?";
console.log(msg);
console.log("\nHell?\n");

printPyramid(9);

updateCanvasSize(); // Initialize canvas size
window.addEventListener('resize', updateCanvasSize); // Recenter canvas on window resize
canvas.addEventListener('click', updateCanvasSize);

